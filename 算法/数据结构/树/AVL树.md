# AVL树

[AVL树可视化](https://www.cs.usfca.edu/~galles/visualization/AVLtree.html)

[AVL树详解](https://zhuanlan.zhihu.com/p/56066942)

AVL树也叫自平衡二叉查找树. 基于二叉查找树. 特点为: 

1. 左子树(存在的话)上所有的值小于他的根节点(右子树则大于) (二叉查找树的特性)
2. 每个节点左右子树高度之差的绝对值 <= 1

> AVL树，本质上是带了自动平衡功能的二叉查找树

​		

## AVL树自平衡

**最小失衡子树**: 在新插入的结点向上查找, 第一个平衡因子的绝对值超过1的节点为根的**子树**称为最小不平衡子树

只要调整最小的不平衡子树, 就能够将不平衡的树调整为平衡的树

示例: 

![img](AVL%E6%A0%91.assets/v2-2ddb0f9b832fff594e294dffc299b373_b.webp)

上图新加入节点`99`后

66的左子树高度为1, 右子树高度为3. 此时平衡因子为 -2

因为是加在右子树上, 所以右子树(`77`) 即为最小失衡子树



### 旋转

旋转的目的就是**减少高度**, 通过降低整棵树的高度来平衡. 哪边的树高, 就把那边的树向上旋转

可以分为**左旋**和**右旋**

左旋: 

1. 节点的右子节点替代此节点位置
2. 右子节点的左子树变为该节点的右子树
3. 节点变为右节点的左子树

> 有点绕, 看动图理解. 核心为降低整棵树的高度
>
> 左子树插入导致不配合就右旋, 右子树插入导致不配合就左旋

![左旋](AVL%E6%A0%91.assets/v2-db1cdb0da952a71f9b6d64b2608467eb_b.webp)

### 特殊情况

单纯的左旋右旋适合`从左子树的左节点插入(LL, RR)`这类情况. 

如果`从左子树的右节点插入(LR, RL)`就不能单纯使用一次旋转了

​		

如`从左子树的右节点插入节点(LR)`: 

从A的左子树(B)的右节点(E)插入节点(F)

![从左子树的右节点插入节点_LR](AVL%E6%A0%91.assets/v2-f95f74ae3e76458d56ae3208bdde5987_720w.jpg)

若直接右旋, 树仍然会失衡

![img](AVL%E6%A0%91.assets/v2-08181fd36341e5925f732a97f1fe8e3c_720w.jpg)

此时应该进行2步操作:

1. 对**最小失衡子树**进行左旋(L)
2. 对**失衡节点**进行右旋(R)

![对最小失衡子树进行左旋_L](AVL%E6%A0%91.assets/v2-e60c01fa31634d9c63c63ecfb58036b2_720w.jpg)

![对失衡节点进行右旋_R](AVL%E6%A0%91.assets/v2-37639b80cb65b60a531d3f5dc73dad52_720w.jpg)

> LL => 右旋
>
> RR => 左旋
>
> LR => 左旋+右旋
>
> RL => 右旋+左旋

