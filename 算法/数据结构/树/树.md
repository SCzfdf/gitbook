# 树

[可视化数据结构](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

一种抽象数据类型. 由n个有限节点组合成一个具有层次关系的集合, 可视化后看起来像一颗倒挂的树

它具有以下特点:

1. 有且仅有一个特殊的称为根的节点
2. 当n>1时其余节点可分为m个不相交的有限集. 每一个集合本身又是一个数, 并称为子树

​		

## 术语

只写较为难懂的几个

* 节点高度: 节点到叶子节点的最长路径
* 树的高度: 根节点的高度
* 节点深度: 根节点到节点经历的边的个数
* 节点层: 节点深度+1

![树的术语.drawio](%E6%A0%91.assets/%E6%A0%91%E7%9A%84%E6%9C%AF%E8%AF%AD.drawio.svg)



## 树的种类

[满二叉树与完全二叉树的区别](https://blog.csdn.net/u010711495/article/details/117047806)

大致可以分为2类: **无序树**和**有序树**. 

无序树的任意节点之间没有顺序关系. 也称为自有树

**有序树**的任意子节点之间有顺序关系, 又可以细分为以下

* **二叉树**

  每个节点*最多*含有2个子节点的树, 又可以细分为: 

  * **满二叉树**

    顾名思义, 一个满的二叉树. 

    1. 每个非叶子节点都有2个子节点. 
    2. 并且叶子节点都处于相同深度

  * **完全二叉树**

    1. 除最高层外节点数要达到最大
    2. 最高层的叶子节点要从左到右进行排序

  * **排序二叉树(二叉查找树)**

    二叉搜索树作为一种经典的数据结构, 它既有链表的快速插入与删除操作的特点, 又有数组快速查找的优势. 特点是:

    左子树存在的话左子树上所有的值小于他的根节点(右子树则大于)

  * **平衡二叉树(AVL树)**

    在二叉查找树上进行升级, 防止了极端情况, 特点是

    每个节点的左右子树的高度之差的绝对值 <= 1
    
  * **红黑树**

    一种特化的AVL树, 核心区别是左右子树高差有可能大于 1

* **多叉树**(好像没这样叫的...)

  可以拥有2个以上的节点的树. 
  
  * **B树**
  
    一个节点能存储多个元素
  
  * **B+树**
  
    在B树的基础上多了2个特性
  
    1. 非叶子节点不存储数据
    2. 叶子节点之间有指针
    3. 非叶子节点上的元素在叶子节点上都冗余了一份
  
  * **B*树**

> 可以把B树看成是二叉树的优化. 因为二叉树结构其查找的时间复杂度O(log2N)与树的深度相关. 而B树能降低树的深度, 自然会提高查找效率



## 完全二叉树辨别

![完全二叉树辨别.drawio](%E6%A0%91.assets/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BE%A8%E5%88%AB.drawio.svg)





## 树的遍历

树是一个非线性结构, 不能直接遍历. 需要把非线性关联的节点转换为一个线性序列. 

以不同的方式转换, 遍历出来的序列顺序也不相同. 可以分为

* **深度优先**

  * **前序遍历**: 根节点 => 左子树 => 右子树

  * **中序遍历**: 左子树 => 根节点 => 右子树

    > 如果对象是一个有序树那么会顺序输出

  * **后序遍历**: 左子树 => 右子树 => 根节点

* **广度优先**

  * **层次遍历**: 根节点 => 左节点 => 右节点

    > 注意, 这里用的是节点, 而不是子树

​		

示例: 

![树](%E6%A0%91.assets/%E6%A0%91.svg)



前序遍历：1  2  4  5  7  8  3  6 

中序遍历：4  2  7  5  8  1  3  6

后序遍历：4  7  8  5  2  6  3  1

层次遍历：1  2  3  4  5  6  7  8

