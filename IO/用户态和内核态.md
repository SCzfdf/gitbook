# 用户态和内核态

[较深入的讲解, 建议看3遍以上](https://www.zhihu.com/question/306127044/answer/555327651)

[Linux I/O 原理和 Zero-copy 技术全面揭秘](https://zhuanlan.zhihu.com/p/308054212)

​		

## 从CPU实模式与保护模式讲起

首先**所有内存的寻址都是**根据**段基址：段内偏移**来访问的, 这样的地址被称为逻辑地址

之所以使用那么复杂的方法来访问是因为早期寄存器只有16位, 只能进行64KB的寻址. 而CPU地址线有20根地址线, 能进行1MB的寻址. 为了解决这个问题而使用逻辑地址来扩展寻址空间. 

*物理地址 = 段基址 << 4 + 段内偏移*

​		

*   **实模式**

    段寄存器(16位)存放着端基址, 通用寄存器(16位)存放着段内偏移(只用4位). 

    可以直接根据逻辑地址计算出真实地址

*   **保护模式**

    [GDT,LDT,GDTR,LDTR 详解,包你理解透彻](http://www.techbulo.com/708.html)

    [实模式与保护模式的寻址](https://www.cnblogs.com/Hhhighway/p/12684920.html)
    
    [操作系统：实模式到保护模式](https://zhuanlan.zhihu.com/p/54083337)
    
    保护模式的段寄存器由以下组成
    
    *   段选择器(16位 储存**段描述符索引**)
    
    *   段描述符寄存器(64位 **段描述符**)
    
        ![段寄存器](%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81.assets/segment-register-300x148.jpg)
    
    此外要寻找地址还需要一个**GDTR寄存器**支持, GDTR相当于是一个索引, 索引值为GDT(段描述符)的内存所在
    
    >   因为GDR是可以存在内存的任意位置, 但CPU需要知道因此在CPU设计者提供了一个寄存器GDTR来存放GDT的入口
    
    ![GDTR](%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81.assets/GDTR.svg)
    
    段选择器通过索引号和TI找到GDT的一个段描述符, 再根据这个端描述符和通用寄存器里的32位偏移地址获计算出线性地址或者物理地址
    
    ![保护模式寻址](https://img2020.cnblogs.com/blog/1986811/202004/1986811-20200425175536299-1731483055.png)





[保护模式同实模式的区别](https://wenku.baidu.com/view/d49c71d981d049649b6648d7c1c708a1284a0ab8.html)

保护模式和实模式的根本区别是**进程内存受保护与否**

实模式将整个物理内存看成分段的区域, 

操作系统和应用程序没有区别对待. 没一个指针都是指向`实在`的物理地址! 

如果该指针指向了应用系统或其他应用程序的区域并改变了值, 那么对于被改变的对象来说可能是灾难性的

为了克服这种低劣的内存管理方式, 开发商开发出保护模式.

物理内存地址不能直接访问, 虚拟地址要由底层转换为物理地址去访问.

此时进程有了严格的边界



## 特权级

特权级别由CPU提供底层实现(段选择器中的**RPL**), 分别是0, 1, 2, 3其中0是最高级别(针对intel), 是CPU工作状态的标识

由操作系统封装. 如Linux只使用了**0级特权级**和**3级特权级**

当操作系统加载一个用户程序时, 它通常都会指定一个稍低的特权级. 不同特权级别的程序是互相隔离的, 严格限制其互访. 如果要调用特权指令只能通过操作系统转发. 这类调用一般称为系统调用



## 内核态和用户态

[操作系统从用户态切到内核态为什么要使用到中断？ - 高志刚的回答 - 知乎 评论也需要看!](https://www.zhihu.com/question/355721858/answer/893902205) 

[用户态和内核态的区别](https://www.cnblogs.com/gizing/p/10925286.html)

由上面特权级可以知道CPU有4种**工作模式**, 而linux使用了最高级和最低级做了封装

最高级和最低级分别对应

*   **内核态**

    CPU工作模式的一种, 在内核态下, 代码可以访问所有内存和外部设备, 且能直接调用特权指令

*   **用户态**

    CPU工作模式的一种, 在用户态下, 代码只能访问受限的内存, 不能直接访问外部设备, 不能调用特权指令

>   特权指令包括
>
>   ​	启动I/O, 内存清零, 修改程序状态字, 设置时钟(应该不是普通的时钟是`晶体振荡器`, 不过百度了也没看到怎么设置的), 停机等
>
>   非特权指令包括
>
>   ​	控制转移, 算数运算, 取数指令, **访管指令**(使用户程序从用户态陷入内核态)



### 内核态和用户态的切换

当用户程序需要调用外部设备或许要进行IO时, 用户态权限不足以完成, 此时就需要切换到内核态进行下一步操作

用户态切换到内核态有三种方式

1.  **外围设备中断(被动)**

    当外围设备完成用户操作请求后, 回向CPU发出响应中断型号

    此时CPU会暂停执行下一条指令转而执行与中断信号对应的系统程序

    >   硬盘IO, 键盘按键, 鼠标点击等应该都算(但是键盘和鼠标应该做了优化吧, 不然也太频繁了)

2.  **异常(被动)**

    当CPU处于用户态时发生了某些不可知异常

    这时会触发由当前运行进程切换到处理此异常的内核相关程序中, 也就跳到了内核态

    >   比如缺页异常

3.  **系统调用(主动)**

    系统调用的机制其核心还是使用了操作系统为用户特别开放的一个**中断**来实现(如Linux的int 80h中断)
    
    >   用户程序通常调用库函数, 由库函数再调用系统调用, 因此有的库函数会使用户程序进入内核态（只要库函数中某处调用了系统调用）



### 内核态和用户态切换的开销

>   系统调用->CPU状态切换->所有与CPU状态相关的寄存器都会被暂存和修改。不同架构（x86，arm，mips）下修改的寄存器数量不一样，就算都是x86-intel，最新的cpu架构也和多年前我学的时候有变化了。但是基本都有一个总思路：普通的指令执行，每个指令可能修改的寄存器就是1到3个；一旦发生状态切换，那么一个指令触发修改的寄存器一般会是十个以上；而且还会带来cpu流水线的失效，预取的指令失效，预测的分支失效，缓冲失效等问题。
>
>   这些问题以及这些问题延伸出来的问题一起构成了CPU状态切换的“成本”。

自己总结了可能还没那么到位, 直接贴原话吧

>   对不太关注底层的人来说，可以直接回答就是：线程<进程<状态切换。
>
>   
>
>   但是！如果要进行专业的讨论，一定要看下面的细节原理。
>
>   
>
>   首先，线程和进程的定义，和区别。
>
>   在Linux体系下，线程和进程在操作系统级的定义里，是“同一个级别的调度单元”。这就导致了，“线程和进程在某个程度上是同一个东西 ，线程切换和进程切换在某个程度上是同一个东西”，在此基础上，线程和进程又有不同：线程之间共享内存，进程之间没有。这个不同就导致了，线程切换的时候，不需要切换mmu，也就是不需要重设置内存映射相关的所有寄存器，而就像我之前也说过的，所有切换成本都可以考虑为等于寄存器设置/保存/还原的成本。然后线程切换比进程切换就少拷贝一部分寄存器，也顺道少清空一次内存缓存，也就是cpu上的L2，L3 cache这类资源，这就导致了其切换成本就低于了“进程级上下文切换”。
>
>   
>
>   状态切换又不太一样：普通的系统调用导致的状态切换，是不会导致mmu切换的。此时陷入内核态，其对应的内存地址空间映射关系还是和用户态时一样，区别是“指令的权限不一样”了。这会导致一些寄存器变化...但是具体哪些寄存器变化我现在也列不全，但是从原理和我以前学习的印象而言，这个寄存器切换的数量也不少，特别是它涉及到cpu状态寄存器的保存和还原，所以操作量也很大，耗时也很长，可以认为它长于进程切换。
>
>   
>
>   但是：真正在实际操作中，我们也经常会认为“系统调用耗时小于进程切换耗时”。
>
>   根源在于：Linux的进程切换，往往是伴随着系统调用和状态切换来产生的（具体原理请看Linux内核关于调度的设计）。也就是，日常我们操作中看到的“进程切换”实际上是“进程上下文切换+多次状态切换”的时间。
>
>   这就导致了我们日常开发中，说“cpu工作模式切换耗时比进程切换耗时少”也不算错的原因。



## 内核空间和用户空间

[12张图解Linux内存管理](https://zhuanlan.zhihu.com/p/339800986)

[Linux用户空间与内核空间（理解高端内存）](https://www.cnblogs.com/wuchanming/p/4360277.html)

上文提到内核态和用户态操作内存空间有所不同, 具体的区别是

CPU会为每个进程分配4GB的虚拟空间.

>   32位系统虚拟地址空间大小为2^32 = 4GB
>
>   64位系统虚拟地址空间大小为2^64 = 16GB
>
>   物理内存超过虚拟内存的则用高端内存映射

4GB的虚拟空间会被进一步分成2部分: **用户空间**和**内核空间**

![32位linux用户空间和内核空间](%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81.assets/v2-a7eb1dadad9aec559d7fedeb8b97ae84_1440w.jpg)



*   **用户空间**

    用户进程能访问到的是用户空间, 每个进程都有独立的用户空间

    虚拟地址范围从`0x00000000` 至 `0xBFFFFFFF` 总容量3G 

*   **内核空间**

    内核空间被所有用户进程共享, 但不能直接访问(通过特权级进行控制)

    虚拟地址范围从 `0xC0000000` 至 `0xFFFFFFFF` 总容量为1G





## 总结

用户态和内核态表示的是CPU的工作模式

用户空间和内核空间是CPU工作模式的具体体现(?)

>   网上很多博客说运行在内核空间的代码就是内核态, 运行在用户空间的代码就是内核态
>
>   感觉反了, 应该是内核态才有权操作内核空间的内存, 用户态只能操作用户空间的内存





## 内核缓冲区缓存和用户缓冲区

[用户进程缓冲区和内核缓冲区](https://www.cnblogs.com/yc3110/p/10440613.html)

![IO拷贝流程](%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81.assets/v2-e3b554661358b18b3f36cc17f0b0c8c1_1440w.jpg)

*   **内核缓冲区缓存**

    在内核空间之中, 用户不能直接控制

    作用是在操作系统级别提高磁盘IO效率, 优化磁盘操作

    >   因为用户不能直接读取文件, 所以其实是程序叫操作系统读取文件给到程序
    >
    >   操作系统不能读取1字节就给到程序, 因此增加缓存区临时保存读取到的文件
    >
    >   另外操作系统还会在缓存区上做些优化, 如进程要求读取1k的数据, 操作系统可能会将后续1k的数据读取到缓存. (忘记在哪看到的...)
    >
    >   其实搞不懂虽然用户态不能直接访问文件, 但是为什么内核不能直接将数据写到用户缓冲区...
    >
    >   后面虽然有mmap, 不过感觉还是有点差别的

    关于缓冲区还可以再细分一点, 不过看的有点蒙, 后续可以继续接着看[Linux I/O 缓冲区那一块](https://zhuanlan.zhihu.com/p/308054212)

*   **用户缓冲区**

    在用户空间之中, 用户直接控制

    作用是减少系统调用的次数

    下面代码的`byte [] r1 = new byte[1024];`就是用户缓冲区

    ```java
    public static void main(String[] args) throws IOException {
        InputStream inputStream = new FileInputStream("E://A.txt");
        byte [] r1 = new byte[1024];
        while (inputStream.read(r1) != -1) {
            System.out.println(new String(r1));
        }
        inputStream.close();
    }
    ```

