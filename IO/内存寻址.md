# 内存寻址

[LINUX 逻辑地址、线性地址、虚拟地址和物理地址](https://blog.csdn.net/baidu_35679960/article/details/80463445)

[GDT,LDT,GDTR,LDTR 详解,包你理解透彻](http://www.techbulo.com/708.html)

以下的都是x86架构下32位linux系统的寻址

​		

*   **逻辑地址**

    逻辑地址由48位组成, 段选择符(16位) + 段内偏移(32位)

    ![段选择符](%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80.assets/%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6.svg)

*   **线性地址**

    线性地址逻辑地址转换成物理地址的一个中间状态

    是一个32位无符号整数(因此最大可以表示4GB的地址)

    线性地址通常使用16进制表示: 0x00000000到0xffffffff

*   **物理地址**

    地址从0开始编号, 顺序加1. 用二进制表示, 是一个无符号整数, 书写格式为16进制



## 实模式寻址

实模式的逻辑地址是由16位的基地址+4位的段内偏移组成的

计算直接通过 **基地址 << 4 + 段内偏移** 得到



## 保护模式寻址

保护模式的寻址比实模式复杂很多

主要是通过一个叫MMU(内存管理单元: memory management unit)的组件转化

MMU主要可以分为2个部件

*   段是内存管理单元
*   页式内存管理单元

![保护模式寻址](%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80.assets/20180526172718371)



### 段式内存管理单元

主要功能是将逻辑地址转换为线性地址, 

主要流程为:

以下是根据多篇博文加自己理解整理出来的, 详细的流程都没说(可能寻址就不是固定的?), 所以可能有错

1.  从逻辑地址中获取段选择符, 根据TI位判断是查询GDT(全局描述符表)还是LDT(局部描述符表)

2.  从GDTR寄存器中获取对应GDT表的内存位置(基地址)

    ![GDTR](%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80.assets/GDTR.svg)

    >   GDT (Global Descriptor Table 全局描述符表), 一个处理器对应一个GDT. GDT可以放在内存的任何位置, 但CPU必须知道对应的基地址, 因此专门提供了一个GDTR寄存器来存放GDT的入口
    >
    >   机器刚加电或处理器复位后, 基地址被默认地设置为0, 而长度值被设置成0xFFFF. 在保护模式初始化过程中必须给GDTR加载一个新值

3.  将GDT的基地址加上**段选择符**中的描述符索引(高13位)获取具体的**段描述符**

    >   大概是GDTR只存一个基地址, 如果有新的段描述符进来在低16位的界限上加1
    >
    >   所以GDT大概可以存8191(13位, 段选择子的长度)或者65535(16位全用上的话)个段描述符

4.  用段描述符(GDT中的东西)中的基址加上逻辑地址中的段内偏移即可得到线性地址

    >   GDT的结构就不说了, 看不懂, 反正有基址就对了, 还有一个**DPL表示特权级**表示操作这个内存需要的最低权限

上面只说了GDT, 还有个叫LDT的不展开了= =





### 页式内存管理单元

[线性地址转换为物理地址是硬件实现还是软件实现?]( https://www.zhihu.com/question/23898566/answer/45538507)

线性地址如果开启分页的话需要经过页式内存管理单元才能转换为物理地址, 如果未开启则线性地址为物理地址

是否开启由寄存器CR0的最高位PG位控制, 如果PG=1则分页机制生效

将线性地址分为三部分

![线性地址](%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80.assets/%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80.svg)

主要流程为:

1.  从cr3寄存器中取出进程的页目录基址
2.  根据页目录基址和线性地址的前10位经过计算(不知道怎么算的...大概也是偏移吧)得出页表基址
3.  根据目录基址和线性地址的中间10位得出 物理页的基址
4.  物理页和页偏移获取具体的物理地址

![img](%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80.assets/4379b9bd2f2b850d4c8046f9f08337ff_1440w.jpg)



一个比较形象的比喻

>   [如何理解虚拟地址空间](https://www.zhihu.com/question/290504400/answer/485124116)
>
>   系统：CPU我给你个逻辑地址0xff84ed43，你去找到这个人
>
>   CPU： 好的系统，我去问问MMU。 MMU，我这里有个地址0xff84ed43，你帮忙找一下
>
>   MMU： 好的，请求分段单元，这个地址你先找到他家所在街道的地址
>
>   分段单元：报告，已经找到了他家所在的街道地址，地址是0x56ac21fe
>
>   MMU：好的，请求分页单元，这个是他家的街道地址，你找到他家住几号。
>
>   分页单元：报告，已经找到了，他家具体地址是0x12345678
>
>   CPU：谢谢，我这就去找他



终于知道了为什么32位linux系统最大只支持4G内存. 因为再多就索引不到了. 

上面内存寻址是超级精简版, 不过再深也没必要了~起码学了C再看深一点吧





