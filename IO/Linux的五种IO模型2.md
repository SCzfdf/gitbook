# Linux的五种IO模型2

[Unix/Linux 中的五种 I/O 模型(很多干货!!!)](https://jacktang816.github.io/post/iomodel/)

[IO 模型知多少 | 理论篇](https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html)

​		

## 信号驱动IO

信号驱动IO主要用于UDP(TCP还搞不明白的我...). 

简单来说会进行2次系统调用

1.  监控文件描述符. 进程向内核注册一个信号处理函数, 作用是数据在内核空间就绪时会发送一个信号给进程
2.  在信号处理程序中将数据拷贝到内核空间

信号驱动式IO模型的主要优点是**在等待数据到达期间, 进程不会被阻塞**

​		

>   实际上I/O多路复用、信号驱动I/O以及epoll都是用来实现同一个目标的技术——**同时检查多个文件描述符是否准备好执行I/O操作**（准确的说是看I/O系统调用是否可以非阻塞地执行）。文件描述符就绪状态的转化是通过一些I/O事件来触发的，如输入数据到达、套接字连接建立完成或者是之前满载的套接字发送缓冲区在TCP将队列中的数据传送到对端之后有了剩余空间。但是以上这三种技术都不会实际执行I/O操作，只会告诉我们某个文件描述符已经处于就绪状态，此时我们还需要调用其他系统调用来实际完成I/O操作。**AIO技术是POSIX异步I/O，**其允许进程将I/O操作排列到一个文件中，当操作完成后得到通知，其优点是最初的I/O调用会立刻返回，进程不会一直等待数据传达到内核或者等待操作完成。这使得进程可以同I/O操作一起并行处理其他任务。

整体流程如下(贴网图吧= =不熟悉)

![图片](Linux%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B2.assets/640)



## 异步IO

[为什么Netty使用NIO而不是AIO？](https://www.jianshu.com/p/df1d6d8c3f9d)

一句话概括: 数据拷贝的时候进程无需阻塞.

异步IO不会导致请求进程阻塞, 即无需等待IO操作完成就将控制器返回给用户进程

>   相对阻塞IO: 必须等待IO操作完成以后控制权才返回给用户进程

​		

个人感觉AIO最大的缺点是必须预先分配内存(不过这又是必要的...). 如果线程数量很多的情况, 占用的内存可能就会很多了

最大的优点则是: 最初的I/O调用会立刻返回, 进程不会一直等待数据传达到内核或者等待操作完成. 这使得进程可以同I/O操作一起并行处理其他任务

​		

整体流程如下:

![AIO用户态和内核态](Linux%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B2.assets/AIO%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81-1625580039001.svg)





## 总结

![img](Linux%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B2.assets/17175f19bb874153)

IO 模型的演进，其实就是时代的变化，倒逼着操作系统将更多的功能加到自己的内核.

​		

但并非新版本就更好, AIO是在NIO之后推出的. 但AIO不一定就比NIO快, 同理BIO也是一样.

合理的选型才是真的. 特别是AIO和NIO代码一个比一个复杂...

