# 分库分表的缺点

[数据库分库分表带来的问题](https://blog.csdn.net/kidchildcsdn/article/details/114678265)

每一次都觉得分库分表是个坑, 一个好的, 完整的数据产品应该是自带横向扩容的

用中间件来实现分库分表就好像打补丁一样. 还会有附带的问题

1. [**事务问题**](#事务问题)
2. [**分页, 排序, 函数问题**](#跨表分页, 排序, 函数问题)
3. [**数据迁移, 扩容问题**](#数据迁移, 扩容问题)
4. [**全局主键避重问题**](#全局主键避重问题)



## 事务问题

[Mycat事务](https://blog.csdn.net/ko0491/article/details/108717088)

[mycat XA事务注意点](https://www.yuque.com/books/share/6606b3b6-3365-4187-94c4-e51116894695/xsf11p)

在单库前提下, 事务可以通过数据库自带的事务处理器确保ACID, 但分库分表之后就要依赖中间件提供的分布式事务了

mycat(v1.21-2022-4-7)提供的分库分表事务目前缺少死锁检查, 官方有3种解决方案

1. 在业务层使用**全局锁**
2. 或者使用**单库分表**来避免
3. 是用mycat内置锁 函数, 强制使事务串行



## 分页, 排序, 函数问题

[Mycat 分页查询过程及注意事项(坑点)](https://blog.csdn.net/chenqiushi123/article/details/109748451)

在单库中只需要一次查询的语句需要调用n次, 并且会对语句进行修改, 比如

```sql
# 原生语句
SELECT * FROM table_name WHERE type='xxx' ORDER BY create_time LIMIT 10000,1000;

# mycat查询语句
SELECT * FROM table_name WHERE type='xxx' ORDER BY create_time LIMIT 0,11000; 
```

这是因为要返回正确的结果集只能从各个数据库查询尽可能大的结果集然后在中间件中进行内部排序, 筛选. 很容易造成OOM

当然查询问题在支持横向扩容的数据库中也是存在的, 但是这应该由数据库内部解决. 而不是用中间件改写sql...

> 同时中间件拥有的资源肯定没有数据库多, OOM的概率比数据库大

![分库分表查询](%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E7%BC%BA%E7%82%B9.assets/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%9F%A5%E8%AF%A2.png)





## 数据迁移, 扩容问题

随着数据增多分库分表之后还需要添加新表时就要考虑对数据进行迁移

1. 数值范围分表, 只需要添加新的表就可以进行扩容, 不需要对原来的分表数据进行迁移
2. 数值取模分片, 就需要对数据进行迁移以及后续的扩容



## 全局主键避重问题

分库分表之后数据库自带的主键**自增**和**唯一性校验**都不能使用了, 需要单独设计全局主键来避免主键重复

> 感觉是分库分表最好解决的问题

1. 使用Snowflake算法(分布式自增ID算法, 64位Long型数字)生成主键

2. 设置数据库自增的步长同时给定一个起始值

   ```properties
   # 在my.conf上修改
   # 自增长字段每次递增的量
   auto_increment_increment=2
   # 自增长字段从那个数开始
   auto_increment_offset=2
   ```

3. 使用UUID(不推荐, 无序主键入库可能会导致B+树变动很大)

