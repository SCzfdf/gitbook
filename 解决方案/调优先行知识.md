# 调优先行知识

调优: 随着**数据量**和**访问量**的增加, 在不增加资源的前提下系统响应时间不可避免的增加. 为了尽可能的利用现有资源而做的一些操作

> 调优是有限的调优

调优从垂直领域可以分为

* 硬件
* 操作系统
* 运行环境
* 应用本身



## 调优流程

![调优大体流程.drawio](%E8%B0%83%E4%BC%98%E5%85%88%E8%A1%8C%E7%9F%A5%E8%AF%86.assets/%E8%B0%83%E4%BC%98%E5%A4%A7%E4%BD%93%E6%B5%81%E7%A8%8B.drawio.svg)



## 定位性能瓶颈

性能瓶颈: 导致系统TPS低, 响应时间长, **资源(CPU, IO, 内存, 网络)**占用高等问题的关键程序模块. 提升该程序模块的性能, 可以大幅度改善性能

这里着重分析**资源(硬件)**的性能瓶颈

对资源的性能瓶颈可能分为2种情况

* **资源占用过高**

  程序对资源已经占用很高了, 但还是很慢. 此时就要增加资源或者找到占用资源多的代码进行优化

* **资源占用不足**

  程序对资源消耗不高. 但是效率很低, 一般体现在
  
  * **锁竞争**
  
    线程锁/死锁/分布式锁. 在竞争或者等待锁时对资源利用率是很低的
  
    可以采用无锁化设计或降低锁的粒度
  
  * **对资源利用率不够**
  
    能被直接利用的有CPU和内存. 可以考虑使用一些空间换时间/预热/多线程等操作提高资源利用率
  
  * **数据库或者存储设备的性能较低**
  
    在等待储存设备IO时对内存的利用率也是很低的, 但却会明显降低响应速度. 可以对数据进行缓存/迁移到另一方速度较快的地方/对数据库进行优化
  
  * **第三方服务请求较慢**
  
    对接多个三方服务或者对代码进行异步化
  
  * ......

无论是资源占用过高还是过低都会有一定体现. 可以根据资源消耗情况来分析



### CPU消耗分析

CPU主要工作有

* **响应硬件中断**

  网卡通讯, 响应键盘输入等硬件输入

* **执行内核空间线程**

  包括读写文件, 上下文切换, 维护线程运行队列等需要内核处理的任务

* **执行用户空间线程**

  软件的主要工作

​		

可以使用`TOP`命令来查看CPU的消耗

![image-20220610141415914](%E8%B0%83%E4%BC%98%E5%85%88%E8%A1%8C%E7%9F%A5%E8%AF%86.assets/image-20220610141415914.png)

> top命令下按1可以查看多核CPU的详情. H可以展示线程信息

```txt
us(user cpu time) — 用户空间占用CPU的百分比。
sy(system cpu time) — 内核空间占用CPU的百分比。
ni(nice cpu time) — 改变过优先级的进程占用CPU的百分比
id(idle) — 空闲CPU百分比
wa(iowait) — IO等待占用CPU的百分比
hi(hardware irq) — 硬中断占用CPU的百分比
si(software irq) — 软中断占用CPU的百分比
st(steal time) — 0表示流畅, CPU资源充足. 当数值增加时表示服务器资源不足
```

​		

在进一步, 使用`pidstat -p <pid> -t`查看程序内线程的CPU利用率情况

![image-20220610143618468](%E8%B0%83%E4%BC%98%E5%85%88%E8%A1%8C%E7%9F%A5%E8%AF%86.assets/image-20220610143618468.png)

> 可以看到28924里各个线程(TID)的CPU使用情况

​		

#### 使用命令定位占用CPU最高的线程是哪个

1. 使用`TOP`命令找到最高的PID
2. 在`TOP`命令下输入`H`切换为线程模式获取对应的TID
3. 将TID转为16进制(`printf "0x%x\n <tid>"`)
4. 使用`jstack <pid> | grep -A 20 <16进制Tid>`来查询对于代码在哪

> 只能对固定的线程有效, 如果tid频繁变化说明可能是cpu在频繁创建/销毁线程

简而言之就是找到对于的进程ID和线程ID就可以找到对应的代码位置

ID可以用TOP命令也可以用其他的一些工具, 比如JMX

这里只展示最简单的排查方法, 不过万变不离其宗, 只要找到占用CPU资源异常的进程/线程就可以找到对应代码. 从而进行调整



### 磁盘IO消耗分析

计算机中最慢的储存介质, 针对磁盘的IO就会有消耗

可以使用`iostat`查看IO消耗

![image-20220610155049202](%E8%B0%83%E4%BC%98%E5%85%88%E8%A1%8C%E7%9F%A5%E8%AF%86.assets/image-20220610155049202.png)

```txt
%user：CPU处在用户模式下的时间百分比。
%nice：CPU处在带NICE值的用户模式下的时间百分比。
%system：CPU处在系统模式下的时间百分比。
%iowait：CPU等待输入输出完成时间的百分比。
%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。
%idle：CPU空闲时间百分比

!!! 
%iowait过高表示硬盘存在IO瓶颈
%idle过高但系统响应仍然较慢. 有可能是CPU正在等待内存分配, 可以尝试增大内存容量
%idle过低(持续低于10)表示系统的CPU资源不足
!!!

device:磁盘名称
tps:每秒钟发送到的I/O请求数.
Blk_read/s:每秒读取的block数.
Blk_wrtn/s:每秒写入的block数.
Blk_read:读入的block总数.
Blk_wrtn:写入的block总数.
```



### 内存消耗分析

比硬盘IO要快上一点的储存介质, 用于做缓存比较多

值得注意的是有内存有一块swap区(交换区), swap区实际上属于硬盘. 简单来说就是系统会分配64G的虚拟内存给每个程序. 但实际内存只有6G或者更少, 就会将新热数据储存在内存中, 冷旧数据会放到交换区里

​		

对于Java来说一般只会关注JVM的内存. 比较少会用到堆外的内存. 可以用以下命令在OOM时自动拍摄快照, 也可以在系统正常允许时用jconstant进行一个监控或者其他工具

```bash
# OOM的时候自动dump内存快照出来
 -XX:+HeapDumpOnOutOfMemoryError
 # 把内存快照放到哪儿去
 -XX:HeapDumpPath=/usr/local/app/oom
```

​		

对于系统层面, 可以使用`vmstat`或`free -m`

![image-20220611162407088](%E8%B0%83%E4%BC%98%E5%85%88%E8%A1%8C%E7%9F%A5%E8%AF%86.assets/image-20220611162407088.png)

```txt
procs
r：运行队列中的线程数目，代表线程处于可运行状态，但CPU还未能执行. 这个值可以作为判断CPU是否繁忙的一个指标；当这个值超过了CPU数目，就会出现CPU瓶颈了；这个我们可以结合top命令的负载值同步评估系统性能；
b：等待IO的进程数量；如果该值一直都很大，说明IO比较繁忙，处理较慢；

memory
swpd：虚拟内存已使用的大小；如果swpd的值不为0，但是si，so的值长期为0，这种情况不会影响系统性能；
free：空闲的物理内存的大小；
buff：用作缓冲的内存大小；
cache：用作缓存的内存大小；如果cache的值大的时候，说明cache处的文件数多，如果频繁访问到的文件都能被cache处，那么磁盘的读IO bi会非常小；

swap
swap（交换空间，单位：KB）；内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。有时我们看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点，还要结合si和so，如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会受到影响的；
si：每秒从交换区写到内存的大小；
so：每秒写入交换区的内存大小；

io
bi：每秒读取的块数；
bo：每秒写入的块数；随机磁盘读写的时候，这2个值越大，能看到CPU在IO等待的值也会越大；

system
system（系统）；这2个值越大，会看到由内核消耗的CPU时间会越大；
in：每秒中断数，包括时钟中断；
cs：每秒上下文切换数；

cpu（以百分比表示）
us：用户进程执行时间(user time)；
sy：系统进程执行时间(system time)；
id：空闲时间(包括IO等待时间)；
wa：等待IO时间；wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈。
```

> 也可以使用之前的`top`命令



## 宏观调优

* **硬件资源**

  1. 垂直扩容(加配置)
  2. 水平扩容(加机器)

* **软件架构**

  1. 应用架构

     单体, 分布式...

     2. 异步化设计

        引入消息中间件

     3. 存储调优

        引入其他更适合的储存方式

     4. 增加缓存

     5. 批处理/预处理

        批量发送/处理消息, 减少IO. 

        预先执行一部分固定的逻辑, 减少执行时间



## 局部调优

主要针对代码层面以及中间件的调优

1. **中间件调优**

   中间件一般都有配置文件, 在公司的特定场景下往往不能完全支持所需要求, 调整配置文件(kafka, mysql, tomcat......)

2. **多核CPU的利用**

   多线程

3. **锁优化**

   使用无锁化设计(cas), 分段锁设计(longAddr, concurrentHashMap)

4. **缓存**

   缓存数据和预热数据

5. **批处理**

   批量处理数据, 减少IO

6. **数据压缩**

   减少网络IO

7. **池化技术**

   复用连接.(中间件连接池, 对象池......)

8. **JVM调优**

9. **网络IO**

   复用连接, 使用NIO等多路复用技术

