**回答问题前先停几秒, 缓解紧张, 放慢语气**



自我介绍

>   以往工作经验与应聘岗位链接、个人的职业发展设想、对应聘企业的个人认同感，至于个人的兴趣爱好之类的，可以简单带过即可，上述的五个简单部分，2、3、4为住，前后两部分为辅助，再加上一些简单的寒暄的话语即可。
>
>   切勿千篇一律(大概模板还是要背的, 不要太流利适当停顿). 要把自己的情况跟企业的职位做链接
>
>   做自我介绍的时候卡壳了. 不要紧张, 坦然地笑笑, 直接说:我有点紧张. 然后继续
>
>   做自我介绍的时候和面试官眼神接触一下, 如果有几个面试官都要扫一扫, 不要光盯着一个

您好, 下面介绍一下我的个人信息, 基本情况简历都有我就不再重复了. 

首先介绍一下之前的工作经验, 从18年11月到2020年1月在恒银金融科技有限公司担任Java开发工程师

*   如果是技术面

    我在其中担任了3个项目的核心开发, 目前均以上线. 该公司主要使用Spring技术栈其中还包括, Redis, Jenkins, Docker, Mysql等多项技术, 

*   如果是hr面

  

之所以离开是因为 {离职原因} 

通过渠道(boss/内推人)关注到贵公司的招聘信息, 该职位跟我未来的职业发展相对比较契合

*   而且贵公司的业务/实例/口碑 对我非常有吸引力, 我非常渴望能够进入贵公司发展(看清楚吹吧...)

我的个人情况是, 现在住在白云区的嘉禾望岗不过面试通过之后会搬到公司附近. (介绍家庭情况和婚育情况好像没必要吧). 闲暇之余会看下技术类的公众号, 也会看下公司代码. 

关于学习这一块. 平时一般通过视频快速了解一项技术, 然后通过书籍和博客查漏补缺. 同时会把学习成果输出到gitbook. 您可以看看(打开电脑, 顺便把代码也挑点给他看看)



离职原因

*   从恒银离职是因为它是一家半外包的公司, 有时候需要驻场开发, 而驻场开发的体验很不好. 不过主要的是做的产品偏向应用软件, 并发量不是很高. 而我希望进入互联网企业, 做一个能抗住百万千万并发的互联网产品
*   而从知识圈离职主要是因为公司资金链出现了问题, 本来招聘一批是想加快产品迭代的, 没想到资金出现了问题. 公司给出了可以继续留下的但要做好工资延迟发放的准备. 而我当时因为个人原因非常需要钱, 一个月出不来工资问题就很严重了. 所以我只能选择离开. 现在据我了解公司已经裁了3批人, 现在后端只有2个开发人员维护 
*   从云七生物科技公司离职主要原因是公司的发展和我的职业规划相悖, 公司主要想我转型做爬虫工程师, 不过我在公司接受这个任务是因为想从另一个方向了解http协议和服务架构, 并不是想转型



职业规划

关于职业规划, 还是比较偏向技术的

我从一个小公司来到xx, 在这样一个大的平台, 能够向周围的优秀同事, 大佬进行学习, 我觉得是一次难得的机会. 

所以我会在接下来的几年时间里从他们身上学到更多, 扎根xx, 在业务上作出更多的成绩. 在专业领域上更有影响力. 争取在2到3年内独当一面. 



为什么想来我们公司

当初是朋友内推, 说公司的技术氛围和整个公司的气氛都是很好的

然后一面过后回去看面试邀请中的pdf和搜索了一下发现公司确实挺不错. 

第一个是资金链稳定, 我看天猫上的时尚彩妆类目, 发现第一页就有2个商品/前3页都有商品(一个129.9的探险家眼影盘排第二,卖了34万笔 ), 因为我有朋友也是做电商运营这一块的, 我知道要做到这种程度是很难的, 需要很多人才和资金. 而且我的上上份工作就是因为资金链出现问题才不得不离开的. 所以这点上我比较看重

第二是公司目前处在上升时期. 我朋友说公司在处于扩招阶段, 需要快速的发展业务. 我一直都很希望在一个体量大的公司做一个互联网项目, 发展也比较稳定



空窗期

>   空窗期里是拿来做职业规划、学习、提升自我的，就加分；全拿来休息，什么都没思考、没有复盘、没有提升的话，就会扣分。 







## IO

IO大概可以分为5种, BIO NIO IO多路复用 信号驱动IO AIO

BIO可以称为阻塞IO, 会在获取链接和获取数据的时候阻塞, 对应代码的Accept和Read方法

NIO也叫非阻塞IO, 非阻塞也主要体现在Accept和Read, NIO解决了Read方法的一半阻塞也即是解决了数据从网卡到内核空间的阻塞





## Spring

### Spring 生命周期

类 => 推断构造方法(用默认的) => 创建普通对象 => 依赖注入(循环依赖) => 

初始化前 => 初始化 => 初始化后 => 

AOP => 代理对象 => Bean



简单的说只有4个阶段

1. 实例化对象
2. IOC依赖注入
3. 初始化
   1. 处理Aware接口
   2. BeanPostProcessor前置处理---全局
   3. InitializingBean接口
   4. 调用对象的init-method
   5. BeanPostProcessor后置处理---全局
4. 销毁
   1. DisposableBean接口
   2. 调用对象的destroy-method



### SpringBoot 自动装配原理

[SpringBoot 自动装配原理](https://blog.csdn.net/qq_43843037/article/details/111320877)

其实就是在项目启动的时候去加载META-INF下的spring.factories文件, 将文件内的类加载到Spring容器中



### Spring事务

分为编程式事务和声明式事务

编程式事务是用**PlatformTransactionManager**或者**TransactionTemplate**硬编码控制事务. 需要手动获取事务对象控制事务的提交和回滚, 对代码侵入性较大

声明式事务是用**@Transaction**控制事务, 使用异常或transactionStatus.setRollbackOnly();来控制事务回滚. 对代码侵入性较小





## ES

### ES搜索为什么快

从架构上看ES的架构是一个集群里有多个节点, 一个节点里面会有多个分片, 一个分片会有多个segment. 这样架构的好处是能支持横向扩容, 只需要增加节点就能增加储存能力. 并且搜索时是基于分片的, 能将请求分发到各个节点, 充分利用CPU性能从而提高搜索效率

并且ES是基于乐观锁控制并发的, 通过version字段来保证并发的正确性, 避免加锁导致的阻塞



## Kafka

## kafka架构

kafka架构可以分为三层,

主题层, 一个主题可以配置多个分区, 每个分区又可以配置多个副本(副本数不能大于Broker数)

分区层, n个副本中只有1个是Leader分区对外提供服务, 其余是追随者副本, 只提供数据冗余

消息层, 分区中包含若干条消息, 每条消息的唯一从0开始递增

另外客户端只能和分区的leader进行交互



### kafka消息无丢失配置

Broker端需要配置禁止ISR外的副本称为Leader, Producer端需要指定ack=all并且使用带回调的send方法感知消息落盘状态. 这里的ack=all表示ISR全部落盘成功

另外可以在Consumer端关闭自动提交. 手动拉取消费完再提交位移. 但在多线程消费的场景下比较难以控制位移更新的, 也即是说可能会出现重复消费





### kafka中的 zookeeper 起到什么作用

controller选举, 检测broker是否存活, 配置管理和服务命名等作用

不过kafka也有了完全脱离zookeeper的打算. 使用基于 Raft 的共识算法, 替代 ZooKeeper,实现Controller自选举





## Redis

### AOF和RDB

AOF会以日志的形式, 记录redis的每一步修改操作到appendonly.aof中, 并且AOF文件过大的话会自动调用rewrite压缩AOF文件. AOF优点是实时性高但持久化的文件大效率较慢

RDB,redis会fork一个线程将数据写入一个二进制文件

> rewrite: redis会fork一个线程由子进程将此时redis的数据全量写入AOF中



### redis数据淘汰算法

可以指定, 具体看配置, 用的最多的是使用LRU算法, 其次是按过期顺序, 最后是随机删除

LRU算法可以将近期最少使用的键值对删除



## JVM

### 运行时数据区

运行时数据区包括: 方法区, 堆. Java虚拟机栈, PC计数器, 本地方法栈

方法区和堆会随着JVM创建而创建. 销毁而销毁, 后面三个则是跟随着线程的生命周期



### 类加载机制

类加载分为3个阶段, 装载 链接 初始化

装载就是将Class文件读取到内存中. 

链接就是将类或者接口并入虚拟机运行时状态, 具体可以分为验证 准备 解析 访问控制和复写. 验证就是验证文件是否合法, 准备就是给变量赋予初始值. 解析就是将符号应用转为直接应用并且将常量池转换为运行时常量池

初始化就是为属性赋予正在的初始值



### 垃圾回收算法

标记清除算法, 分为2个阶段, 一个标记阶段是遍历所有对象并将标记出存活对象和垃圾对象, 一个是清除阶段会遍历并删除所有垃圾对象. 算法的优点是简单速度快, 缺点是会有空间碎片, CMS就是使用这个算法, 因此需要大的内存来规避空间碎片导致的OOM

标记整理算法, 也分为2个阶段, 第二个阶段为整理阶段, 会移动存活对象到一侧. 优点是没有空间碎片, 缺点是比标记清除慢

复制算法, 将内存分为2块区域, 平时只使用一块, GC时将存活对象直接移动到另一块区域, 优点是在小空间的情况下速度快, 缺点是浪费内存. 通常使用在Young区.



### 确定垃圾对象_可达性分析

2个算法, 一个是引用计数, 不过引用计数不能识别循环依赖. 一种是可达性分析, 会从GC root对象开始寻找, 经过2次标记还没达到可达就会标记为垃圾对象

GCroot对象一般从Java虚拟机栈和本地方法栈的栈帧中的本地变量表中寻找, 还有就是方法区中的运行时常量池中寻找









