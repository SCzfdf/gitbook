# 封装·继承·多态

>   [!notice]
>
>   **封装是继承的前提. 继承为多态提供可能性**

1. **封装**

    将类的某些信息隐藏起来, 限制外部访问(通过 *访问对象修饰符* 控制(public...))

    *好处* :

    * 隐藏细节
    * 减少重复代码
    * 继承的前提

    <br>

2. **继承**

    让一个类**拥有**另一个类的属性和方法, 同时衍生出重写和重载

    *好处* :

    * 更贴近面向对象的含义, 更贴近世界
    * 多态的前提

    >   [!note]
    >
    >   重写(覆盖): 子类中有和父类相同的 方法名, 方法参数表, 方法返回类型 则这个方法被认为是父类的重写
    >
    >   >   子类方法的访问控制修饰符必须不少于父类
    >
    >   重载: 子类中有和父类相同的 方法名. 但参数列表不同, 返回类型可以相同. 则这个方法被认为是父类方法的重载

    <br>

3. **多态**

    父类的引用指向子类的对象

    *好处* :

    * 解耦

    > [!note]
    >
    > 多态有几种
    >
    > 1. 对象多态: Person p = new Myself()
    > 2. 参数多态: "".equal(Object o)
    > 3. 返回值多态: Person p = PersonFactory(String sex) (根据传输性别到造人工厂.工厂返回男人或女人) 



一些[观点](https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386820044406b227b3e751cc4d5190420d17a2dc6353000)认为子类不应该定义父类中不存在的方法(定义了就用多态也不能调用)

但个人觉得在面向对象的前提下, 子类有父类不存在的方法也是正常



------

# 再谈封装·继承·多态

封装 

​	对象之间的联系

继承

​	对象之间的层次

多态

​	对象之间的差异

