# LOCK指令与MESI协议





## LOCK#指令

[聊聊CPU的LOCK指令](https://albk.tech/%E8%81%8A%E8%81%8ACPU%E7%9A%84LOCK%E6%8C%87%E4%BB%A4.html)



计算机层面通过LOCK#解决因CPU的多线程多核心机制导致的原子性问题

在CPU的LOCK信号被声明之后, 通过独占总线独享内存. 确保当前对内存的操作只有一个线程. 然后确保在声明期间的操作不会被打断 来确保其原子性



## MESI协议

[总线锁、缓存锁、MESI](https://blog.csdn.net/qq_35642036/article/details/82801708)

[聊聊一致性协议](https://albk.tech/%E8%81%8A%E8%81%8A%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE.html)

>   缓存一致性协议有很多Intel 的MESI协议是最出名的

*   **Modified**

    表示缓存行被修改了, 且没有更新到内存中. 同时只存在于本CPU的缓存中(其他是Invalid)

*   **Exclusive**

    表示缓存行中的数据与内存一致. 同时存在于本CPU缓存中

*   **Share**

    表示缓存行的数据在多个CPU中同时存在, 同时与内存一致

*   **Invalid**

    表示本CPU中此缓存失效





MESI协议对不同的状态增加了不同的监听任务, 具体规则如下

*   **Modified**

    监听试图读取该缓存行对应内存地址的操作. 如果监听到了则必须在读取操作前将数据写回内存

*   **Exclusive**

    监听试图读取改缓存行对应内存地址的操作. 如果监听到了则必须把其状态改为S

*   **Share**

    监听试图使该**缓存行失效**或者**独占该缓存行**的请求, 如果监听到了则必须吧其状态改为I



可以看出MESI协议是**通过在总线上发送和响应请求来保证数据一致性的**

>   当CPU需要写数据时只有M E状态才能够直接执行, 否则需要发出特殊的RFO指令(Read Or Ownership，这是一种总线事务)通知其他CPU设置缓存行为I. 在写入完成后, 修改其本地缓存状态为M. 
>
>   这种操作是开销是比较大的, 如果一个变量被多个CPU频繁修改会不断产生RFO指令, 当然这个我们管不到= =

![缓存一致性](%E6%80%BB%E7%BA%BF%E9%94%81%E5%92%8C%E7%BC%93%E5%AD%98%E9%94%81%E5%AE%9A.assets/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7.png)



何时使用缓存锁定由多重因素决定. 比如CPU架构是否支持, 缓存的内存地址是否跨缓存行(状态无法标识), 是否能被缓存在CPU内部等

