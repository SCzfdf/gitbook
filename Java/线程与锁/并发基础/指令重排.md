# 指令重排

[Java内存模型之有序性问题_指令重排](https://www.cnblogs.com/54chensongxia/p/12120117.html)

[处理器指令重排详解](https://blog.csdn.net/javazejian/article/details/72772461#%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92)

---

as-if-serial语义: **不管怎么排序. 程序在单线程执行的结果都不能被改变**. 

所以编译器和处理器都不会对有依赖关系的操作进行重排序, 因为这种重排序会影响程序在单线程情况下的执行结果

>   编译器, runtime和处理器都必须遵循as-if-serial语义



经典的圆面积计算问题. 在as-if-serial语义的加持下

AB不存在数据依赖可能被重排序. 

(AB)被C依赖, (AB)需要在C之前执行. 不能被重排序

```java
double pi  = 3.14;    //A
double r   = 1.0;     //B
double area = pi * r * r; //C
```



---

指令重排: 遵循as-if-serial语义的前提下为了优化程序性能而对指令序列进行重新排列的一种手段

指令重排分为以下三种

*   **编译器的优化重排序**

*   **指令级的并行重排序**

    现代处理器才用指令级的并行技术将多条指令重叠执行

    >   消除CPU的流水线执行时因数据准备的造成的停顿(详细看参考)

*   **内存系统的重排序**

    由于CPU的高速缓存, 写缓冲区, 失效队列的存在使得加载和储存的操作是乱序的

>   第一个是编译器级别的重排序, 后面两个是处理器级别的重排序

![指令重排](%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92.assets/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92.png)

