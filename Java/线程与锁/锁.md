# 锁

**锁的本质是对共享资源的访问控制**

常用的互斥锁, 如synchronized说白了就是一种互斥资源, 只能由一个线程占用. 当通过竞争获取到这个资源时, 其他线程将不能再度获取



---



## 死锁

**一组线程因资源争抢而导致的互相等待的一种现象, 若无外力推进将永久等待**



### 死锁产生的4个必要条件

[死锁产生的4个条件](https://blog.csdn.net/wljliujuan/article/details/79614019#51-%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6)

[死锁的处理](https://blog.csdn.net/rabbit_in_android/article/details/50530960)

*   **互斥**

    一个资源只能被一个线程占用源

*   **请求保持**

    一个线程因为获取资源阻塞时不会释放原有资源

*   **不可强占**

    线程已占有的资源不能被其他线程强行释放

*   **循环等待**

    若干线程请求其他线程已占有的资源 形成一种首位相接的资源等待关系

以上是死锁产生的必要条件, 只要产生了死锁这些条件必然成立(打破了一个就可以避免死锁)



### 死锁预防

*   **互斥**

    互斥锁成立的必要条件, 不可避免

*   **请求保持**

    *   一次性请求所需要的所有资源, 避免多次请求资源
    *   请求资源附带超时时间, 一段时间获取不到资源则释放原有资源
    *   使用不阻塞的方法获取锁

*   **不可强占**

    *   请求资源附带超时时间, 一段时间获取不到资源则释放原有资源
    *   使用不阻塞的方法获取锁, 失败则释放资源

*   **循环等待**

    *   使用顺序获取锁的方式(如果要获取ABC三个锁那么不管使用顺序是如何, 必定是从ABC顺序获取)

