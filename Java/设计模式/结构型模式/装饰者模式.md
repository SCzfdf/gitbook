# 装饰者模式(decorator)

>   装饰者模式: 动态的给一个类附加功能/增加职责



## 参考资料

[装饰者模式概述](https://blog.csdn.net/LoveLion/article/details/7425849)     

[透明&半透明装饰模式&总结](https://blog.csdn.net/LoveLion/article/details/7425873)     

[生动的例子](https://www.imooc.com/article/23976?block_id=tuijian_wz)



## 概念

*   **抽象构件(component) **

    装饰者模式的底层构件,  **具体构件** 和 **抽象装饰类** 的父类. 声明了所需业务方法. 它的引入可以使调用方一致的对待 **具体构件** 和 **装饰类** 

*   **具体构件(concreteComponent)**

    要被增强的类, 业务方法的主要实现者

*   **抽象装饰类(decorator)**

    用于给 **具体构件** 附加职责, 但具体职责在子类中实现. 它维护了一个指向 **抽象构件** 的引用. 通过该引用可以调用装饰前的方法, 并通过子类附加职责

*   **具体装饰类(concreteDecorator)**

    继承 **抽象装饰类** 负责向构件添加职责

>   [!note]
>
>   由于 **具体构件** 和 **装饰类** 都实现了相同的抽象构件接口
>
>   因此装饰模式以对客户 **透明的方式** 动态地给一个对象附加上更多的责任
>
>   装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。



## 一般用法

1.  根据业务抽取 **抽象构件** 
2.  创建 **具体构件** 实现 **抽象构件**, 声明业务方法
3.  创建 **抽象装饰类** 实现 **抽象构件**, 在里维护一个 **抽象构件** 的引用(对象由外部注入), 方法需全部实现, 具体实现为直接调用引用构件的方法
4.  创建 **具体装饰类** 继承 **抽象装饰类**, 在里定义了一些新的行为, 通过重写并调用 **抽象装饰类** 中的方法(super())来增强类功能



## 应用实例

TransactionAwareCacheDecorator




## 优缺点

*   优点

    对于单纯扩展功能来说, 装饰者比继承更灵活, 耦合度更低, 而且没有final限制

    可以用一种灵活的动态方法拓展对象功能(通过配置文件决定装饰类)

    可以对一个对象进行多次装饰, 通过使用不同的装饰类和改变装饰类的顺序. 创造出更强大的对象

    增加新功能只需要增加装饰类, 符合开闭原则

*   缺点

    debug太麻烦了(idea直接ctrl+alt+b会直接跳转到抽象构件而不是具体装饰类...)

    比继承灵活也意味着容易出错(...)

    会产生很多小对象



## 透明装饰者模式&半透明装饰者模式

*   透明装饰者模式

    **具体装饰者** 只针对 **抽象构件** 编程. 抽象构件不存在的不做处理

    创建对象时使用: **抽象构件** 指向 **具体装饰类** (`Component c = new concreteDecorator`())

    对于调用方而言各个构件没有区别

*   半透明装饰者模式

    **具体装饰者** 中 有独立于 **抽象构件** 中定义的方法

    因此客户端需要有区别的对待 **具体装饰者** 和 **抽象构件**

>   [!notice]
>
>   半透明装饰模式可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便
>
>   但是其最大的缺点在于不能实现对同一个对象的多次装饰
>
>   >   对一个半透明装饰者再装饰后 就不能调用其特有的业务方法



## 总结

装饰者模式简单的来说就是

通过注入一个对象, 在调用对象前后添加方法来达到增强对象的目的

可以通过抽取抽象构件和装饰者来进一步解耦,减低聚合和增强其扩展性

具体装饰者是否存在定义独立于抽象构件的方法来划分透明/半透明装饰者模式

这么说来AOP, 事务都是装饰者的一种?

