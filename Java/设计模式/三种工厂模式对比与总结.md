# 三种工厂模式对比与总结

## 概念

**简单工厂**

>   可以根据传入参数不同返回不同类

**工厂方法**

>   声明一个创建对象的接口, 让其子类决定具体实例化哪一个对象

**抽象工厂**

>   声明一组创建一个产品族的方法, 让其子类决定其具体的等级(等级结构)



## 优缺点

>   ![notice]
>
>   **实现了对象创建和使用的分离**. 是核心优点也是意义

**简单工厂**

*   优点
    1.  代码通俗, 逻辑简单
    2.  静态方法, 客户端调用方便
*   缺点
    1.  不使用反射的话, 增加产品要增加分支, 违反开闭原则
    2.  不使用反射的话, 产品和分支的增加对开发和维护, 以及测试(每加一个都要重新测试), 并且到一定程度代码分支过多会难看, 对系统维护和扩展非常不利
    3.  使用反射的话, 只能适用于简单的创建对象和通用配置. 如果需要特殊配置依然需要添加if, 依旧违反开闭原则
    5.  一个工厂负责一个等级结构的创建. 职责过重

**工厂方法**

*   优点

  1.  代码耦合度低, 新增产品符合开闭原则
*   缺点
    1.  产品与工厂1:1, 类个数成对增加

**抽象工厂**

*   优点
    1.  解决了工厂方法的缺点, 系统类不会成对出现
    2.  代码耦合度较低
*   缺点
    1.  开闭原则有倾斜性, 新增产品等级会违反开闭原则



## 三种模式转换

*简单工厂*

简单工厂, 只抽象产品类, 一个工厂可以生产全部商品

*简单工厂->工厂方法*

将生产产品的方法放到抽象类/接口中, 需要生产什么产品就调用什么工厂, 产品和工厂1:1关系

*工厂方法->抽象工厂*

梳理产品关系, 将产品间的继承关系作为一个维度(等级关系)抽取出来

按照业务划分产品族, 将一族产品放到统一工厂



## 使用场景

**简单工厂**

适用于简单的场景, 如生产逻辑,创建逻辑不复杂的场景, 并且最好在后面开发中不需要大量添加产品.

>   简单的场景使用简单工厂

**工厂方法**

工厂方法最符合设计原则, 但是产品和工厂1:1出现, 不适用于太多种类产品的生产

>   种类少的但逻辑复杂的用工厂方法

**抽象工厂**

抽象工厂因为有产品族和产品等级的概念, 最适合产品等级和产品族必须成对出现的场景(就是下图, 增加一个产品族, 产品等级也要加一个)

![电器工厂的产品等级与产品族](三种工厂模式对比与总结.assets/3-1Q1141559151S.gif)

>   有2个抽象维度的用抽象工厂



## 总结

三种工厂方法各有优点, 要活学活用啊~

