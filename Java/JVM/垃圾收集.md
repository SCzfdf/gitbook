# 垃圾收集

[G1垃圾收集器文档](https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html)



## 确定垃圾对象

[JVM如何判定垃圾的方法？](https://blog.csdn.net/nurture_/article/details/123130657)

可以通过下面2个方法确定对象是否需要被回收

1. 引用计数

   通过判断一个对象的引用数量决定这个对象是否需要回收. 

   优点是算法简单. 缺点是需要引入额外计数器和难以判断循环依赖

2. 可达性分析

   GCRoot对象开始寻找引用, 经过两次标记还没有可达, 就会被标记为垃圾对象

   > GC Root: 栈帧中局部变量表中的对象, 方法区中常量或者静态变量, 本地方法栈中的本地对象....等等都可以称为GC Root
   >
   > 下图`Obj7`和`Obj8`就是垃圾对象

   ![可达性分析](%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86.assets/image-20220627201634130.png)



## 垃圾回收算法

1. **标记清除算法**

   算法分为2个阶段: 

   标记阶段: 遍历所有的对象标记出存活对象和垃圾对象

   清除阶段: 遍历所有的对象删除所有的垃圾对象

   优点: 简单

   缺点: 需要遍历2次, 并且清除后会有空间碎片

2. **标记整理算法**

   算法分为2个阶段: 

   标记阶段: 遍历所有的对象标记出存活对象和垃圾对象

   整理阶段: 将标记对象向一段移动

   优点: 没有空间碎片

   缺点: 比标记清除算法要慢

3. **复制算法**

   把内存一分为二, 平时只使用一个, 触发GC时将存活对象迁移至另一个内存

   优点: 效率比标记整理快, 同时也没有内存碎片. 数据量不大时较为高效

   缺点: 浪费空间

> 效率上：复制算法>标记清除>标记整理
>
> 内存利用率：标记整理> 标记清除>复制算法
>
> 内存连续度：标记整理 = 复制算法 > 标记清除
>
> -------------------
>
> 年轻代：对象存活率不高，频繁的垃圾回收，使用“复制算法”
>
> 老年代：对象存活率相对较高，使用“标记清除”或者“标记整理算法”



## 垃圾收集器

[垃圾收集器官方文档](https://docs.oracle.com/en/java/javase/17/gctuning/available-collectors.html#GUID-F215A508-9E58-40B4-90A5-74E29BF3BD3C)

垃圾收集器就是上述算法的落地产品

* **Serial Collector**

  串行收集器. 使用单线程来执行所有垃圾收集工作. 没有线程通讯的额外开销, 但不能充分利用多核CPU. 因此在小内存(100M)下相对高效. 适用于Old和Young

* **Parallel Collector**

  并行收集器也叫作吞吐量收集器. 多线程收集. 适用于Old和Young

* **Concurrent Mark Sweep(CMS)**

  CMS收集器, 停顿时间比较短(约500ms), 使用的是标记清除法因此会有空间碎片. 适用于Old

* **Garbage-First (G1) Garbage Collector**

  G1收集器, 会尽可能的满足设定的停顿时间(约200ms), 并且很好的解决了空间碎片问题, 适用于Old和Young

  > 大概有那么多对象需要收集再收集, 会进行多次GC

* **The Z Garbage Collector**

  Z收集器, 提供一个低停顿时间(8ms). 停顿时间和堆大小无关, 但吞吐量会下降. 适用于Old和Young

> 吞吐量: 吞吐量侧重于在特定时间段内最大化应用程序的工作量. 如在给定时间内完成的事务数. 
>
> 响应时间/停顿时间: 响应性是指应用程序或系统响应请求的数据的速度. 如网站返回页面的速度

​		

按照执行类型分类

* 串行: 只有一个垃圾收集线程执行: Serial
* 并行: 有多个垃圾收集线程执行, 业务代码不执行: Parallel. 更加关注吞吐量
* 并发: 垃圾收集和业务代码会共同执行: CMS, G1, Z. 更加关注停顿时间

> 吞吐量计算公式: 业务代码执行时间/(业务代码执行时间+GC时间). 如果在web项目中使用Parallel可能会导致某个点GC1秒, 对客户不友好(感觉问题不大...)



## Stop the world

Stop the world(STW)是Java中一种全局暂停现象, 所有Java代码停止, native代码可以执行, 但不能与JVM交互

所有垃圾收集器都存在STW, 只是时间长短不一样

STW是为了避免业务代码在获取对象时该对象正在被移动, 导致获取错误地址





## CMS收集器

并发收集器的一种, 适用于Old区. CMS追求低停顿时间采用的是标记清除算法. 如果碎片问题导致OOM请分配更大的堆内存

> Old指定了CMS, 默认情况下Young区会使用Parallel进行垃圾回收

CMS 收集器在老年代堆上执行以下阶段：

| 阶段               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| (1) 初始标记 (STW) | 标记GC Root                                                  |
| (2) 并发标记       | 遍历所有GC Root, 并标记. 基本gc整个的耗时都在这个阶段, 大概占80% |
| (3) 重新标记(STW)  | 修正由于并发标记没有STW导致标记变动的那部分对象. 耗时一般比初始标记长但比并发标记短 |
| (4) 并发清理       | 开启用户线程, 同时GC线程清理未标记对象. 如果有新增对象则会标记为黑色, 不做处理 |
| (5) 复位           | 重置GC过程中标记的对象                                       |

