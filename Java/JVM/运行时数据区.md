# 运行时数据区

[Java 虚拟机的结构](https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-2.html)

JVM定义了在程序执行期间使用的各种运行时数据区域.

其中一些数据区域(方法区, 堆)是在JVM创建时创建, 只有在JVM推出时才会被销毁. 

其他数据区域(Java虚拟机栈, PC Registers, 本地方法栈)在线程创建时创建, 线程退出时销毁

​		

换句话说就是**方法区和堆**随着进程创建而创建. 随着进程销毁而销毁. 并且方法区和堆会被所有线程的共享会存在线程安全问题.

**Java虚拟机栈, PC Registers, 本地方法栈**, 随着线程创建而创建, 随着进程销毁而销毁. 只会被当前线程访问. 不存在线程安全问题

​		

运行时方法区可以分为以下5个部分:

1. [**方法区**](#方法区)

   存储的是每个类的结构信息

2. **堆**

   为所有类实例和数组分配内存的运行时数据区域

3. [**Java虚拟机栈**](#Java虚拟机栈)

   保存执行方法时生成的栈帧(可以说是储存方法的调用信息)

4. **PC Registers**

   储存Java虚拟机栈当前正在执行虚拟机指令地址. 如果是native方法则为空

5. **本地方法栈**

   类似Java虚拟机栈, 不过保存的是native方法的栈帧

![HotSpot架构图](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.assets/Slide1.png)

## 方法区

**存储的是每个类的结构信息**. 包括**运行时常量池**, 字段和方法数据, 以及方法和构造函数的代码, 包括类和接口初始化以及实例初始化中使用的特殊方法

​		

这里的运行时常量池和String常量池并不是一个概念

String常量池在Java7以前是储存在方法区的, 之后转移到了堆内存

这样做的目的是方法区很少发生垃圾回收, 而堆内存垃圾回收比较频繁, 放到对内存中会更容易管理

> Java7以前运行时常量池可和String常量池可能是一个概念, 但7之后就肯定不是了



## Java虚拟机栈

每个方法被执行的时候，Java虚拟机都会同步创建一个**栈帧**并存放到栈中

栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息

栈有先进后出得特性, 当栈为空时说明方法已经调用完毕



## 可能发生OOM的区域

OOM即为内存溢出, 表示JVM占用的内存区域不够下一次操作.

占用内存的区域有: 方法区, 堆, Java虚拟机栈, 本地方法栈(栈帧的创建). 因此OOM可能会在以上区域发生. 不过通常都是堆

其中Java虚拟机栈和本地方法栈还可能会抛出StackOverflowError, 抛出时说明递归调用太深了



