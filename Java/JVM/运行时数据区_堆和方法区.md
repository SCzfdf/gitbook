# 运行时数据区_堆和方法区

[JVM内存结构分析：为什么需要S0和S1?](https://www.cnblogs.com/duanxz/p/6076662.html)

首先方法区是一种JVM规范, 具体的实现在不同版本的JDK中有不同的名称

Jdk7以前叫做perm space 永久代

Jdk8以后叫做metaspace 元空间

实际都是指代方法区(也叫做非堆)

​		

## JVM进程共享空间设计

JVM进程共享空间设计总体可以分为2块区域

堆和方法区

堆又可以细分为old区和young区, young区又可以细分为Eden区和2个Survivor区

> 对象生下来在Eden(伊甸园), 经过一次GC且存活下来的会放到Survivor(幸存) :D

![JVM内存空间_堆和方法区](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA_%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20220627190515702.png)



### JVM方法区设计思路

以下是一些前置知识

1. 方法区很少发生GC
2. 绝大多数对象生命周期较短, 很快会被回收
3. GC过后会存在空间碎片, 导致空间不连续
4. 空间碎片不连续会导致JVM有内存足够内存, 但是无法分配空间
5. GC会争抢CPU时间片, 因此GC应该尽量的**快**或者尽量的**少**进行

​		

由1可以得出方法区应该和堆进行拆分, 或者说将从内存中划分出一块区域给变化少的对象. 这类型的对象就是方法区的对象

> 方法区储存: **运行时常量池**, 字段和方法数据, 以及方法和构造函数的代码, 包括类和接口初始化以及实例初始化中使用的特殊方法
>
> 这也是String常量池从方法区拆分出来的理由, String常量池会导致方法区比较频繁的GC

由2可以得出Young区和Old区划分是因为有很大一部分对象会朝生夕死因此将刚创建的对象放到Young区可以减少Old区的GC. 又因为Young区比较小可以更快的GC

> 对象改动频率: 方法区 < Old < Young

​		

划分2个Survivor区的原因是, Young区使用的是复制算法. 当Eden区需要进行GC时将还存活的对象全部写入其中一个Survivor区, 可以优化3, 4, 5带来的问题

并且Survivor区的存在还能尽量阻止对象移动到Old区(Old区比较大, 清理一次耗时比较长)

> 复制算法: 基本思想就是将内存分为两块, 每次只用其中一块. 当这一块内存用完, 就将还活着的对象复制到另外一块上面. 复制算法的优点是不会产生内存碎片

​		

**数据区域的划分本质目的是加快GC.**



### 可视化GC

找到JDK8中自带的工具`jvisualvm.exe`

选择 工具>插件>可用插件>`Visual GC`. 安装.

然后选择监控VisualVM, 切换到Visual GC标签页

> Eden区域会逐步增多 > 满了之后会触发GC > 将Eden还存活的对象和S0(或者S1)还存活的对象迁移到S1(或者S0)
>
> 存活过一次GC的对象age会+1



![image-20220627194528102](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA_%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20220627194528102.png)

> 当S1或者S0不够存放存活对象时会向Old区借空间, 空间担保机制
>
> S区的空间必然会释放出来. 因为当S区对象存活了n次GC年后对象会转去Old区. 如果存活不了n次那么S区的空间就会被释放
>
> Old区不够了 > 触发Old区GC > 还是不够 > OOM


