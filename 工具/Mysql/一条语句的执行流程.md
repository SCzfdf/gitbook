# 一条语句的执行流程

`Select * from user`

1. 客户端与服务端建立链接, 并发送语句
2. ~~查询缓存~~
3. 语法解析
4. 预处理
5. 查询优化
6. 向储存发起请求

​		

![image-20220605173340028](%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.assets/image-20220605173340028.png)

![image-20220611191251150](%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.assets/image-20220611191251150.png)

> 8.0缓存已经取消



## 客户端与服务端建立链接

取决于客户端的编写方式, 一般有以下类型

通讯类型: **同步**/异步. (一般是同步, 异步编码会相对负责)

链接方式: **长链接**/短链接. (一般是长链接, 能复用连接)

协议: **TCP**/Unix Socket. (在本地连接Mysql服务使用Unix Socket, 其他一般使用TCP)

​		

查看服务端连接数

```sql
# 一个线程对应一个连接
SHOW GLOBAL STATUS LIKE 'Thread%'
```

查看连接超时时间

```sql
SHOW GLOBAL STATUS LIKE '%timeout%'
```





## 查询缓存

Mysql中5.7默认关闭, 8.0版本正式移除

Mysql中的缓存很鸡肋

1. 查询语句有一点点不同缓存就不会被命中
2. 表但凡有一行修改缓存会失效

应该把缓存交给更加专业的工具

```sql
# 可以查询缓存情况
show variables LIKE 'query_cache%'
```



## 语法解析

会有一个专门的Parser进行处理, 处理包括以下2项

1. **词法解析**

   把完整sql语句分为一个个单词

2. **语法解析**

   语法检查

经过Parser后会得到一个解析树, 交给后续处理器处理

![image-20220605162202770](%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.assets/image-20220605162202770.png)



## 预处理

会对解析树进行一个检查. 

1. 检查表和列名是否存在
2. 检查明智和别名保证没有歧义

预处理完成之后会得到一个新的解析树



## 查询优化

对查询的解析树进行优化, 会生成多条执行路径, 然后选择认为最优的一条语句. 解析树优化之后得到的结果称为**执行计划**

> 优化是有程度的优化, 不然就不需要sql语句调优了

优化包括但不限于以下部分

* 子查询优化
* 等价谓词重写
* 条件化简(1=1删除)
* 链接(普通链接, 外链接, 嵌套链接)消除
* 语义优化
* 非SPJ优化

​		

查看执行计划, 在sql前加`EXPLAIN`即可

```sql
# format=json => 以Json结构展示
EXPLAIN format=json select * from t_user
```







