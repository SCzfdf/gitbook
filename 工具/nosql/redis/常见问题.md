# 常见问题

[单线程你别阻塞，Redis时延问题分析及应对](https://blog.csdn.net/liudong1105/article/details/50260841)



## redis 持久化

### fork产生的阻塞

AOF和RDB均可能使用fork产生子线程来代替主线程做一些操作避免主线程阻塞. 

fork新进程时, 虽然可共享的数据内容不需要复制, 但会复制之前进程空间的内存页表, 这个时候会产生阻塞(这个看网上例子感觉不大几十G数据阻塞几百ms)

解决: 

 1. 控制redis的最大内存量 (一般建议不超过20G)

    > 可根据自己服务器的性能来确定（内存越大，持久化的时间越长，复制页表的时间越长，对事件循环的阻塞就延长）  

 2.  使用大内存页

    > 默认内存页使用4KB，这样，当使用40G的内存时，页表就有80M；而将每个内存页扩大到4M，页表就只有80K；这样复制页表几乎没有阻塞，同时也会提高快速页表缓冲TLB（translation lookaside buffer）的命中率；但大内存页也有问题，在写时复制时，只要一个页快中任何一个元素被修改，这个页块都需要复制一份（COW机制的粒度是页面），这样在写时复制期间，会耗用更多的内存空间；

 3. 使用物理机

    > 物理机性能比较好?



### 持久化产生的阻塞

子进程的write和主进程的fsync冲突造成的阻塞

在开启了AOF持久化的结点上，当子进程执行AOF重写或者RDB持久化时，出现了Redis查询卡顿甚至长时间阻塞的问题, 此时, Redis无法提供任何读写操作

Redis 服务设置了 appendfsync everysec, 主进程每秒钟便会调用 fsync(),  要求内核将数据”确实”写到存储硬件里. 但由于服务器正在进行大量IO操作(AOF重写或者RDB), 导致主进程 fsync()操作被阻塞, 最终导致 Redis  主进程阻塞 

解决: 

设置 no-appendfsync-on-rewrite yes

最好还是在服务频繁调用时不做处理吧. AOF重写和RDB都搞到凌晨4点. 期间靠AOF来维持数据准确性

> 在子进程执行AOF重写时, 主进程不调用fsync()操作；
>
> 注意, 即使进程不调用 fsync(), 系统内核也会根据自己的算法在适当的时机将数据写到硬盘(Linux 默认最长不超过 30 秒).
> 这个设置带来的问题是当出现故障时，最长可能丢失超过30秒的数据，而不再是1秒；



### AOF重写完成后合并数据时造成的阻塞

在bgrewriteaof过程中, 所有新来的写入请求依然会被 写入旧的AOF 文件, 同时放到AOF buffer中, 当rewrite完成后, 会在主线程把这部分内容合并到临时文件中之后才rename成新的AOF文件,  

所以rewrite过程中会不断打印

"Background AOF buffer size: 80 MB， Background AOF buffer size: 180 MB"，

这个合并的过程是阻塞的

如果产生了280MB的buffer，在100MB/s的传统硬盘上，Redis就要阻塞2.8秒

解决: 

1. 换固态! 
2. 尽量调高AOF重写的阈值. 尽量避免在高峰重写
3. 还是找个时间在空闲定时触发吧



## 主从

### 读写分离导致主从数据库数据不一致问题



