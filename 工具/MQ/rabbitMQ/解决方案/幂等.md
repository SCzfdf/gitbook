# 幂等

[阿里RocketMQ如何解决消息的顺序&重复两大硬伤？](https://dbaplus.cn/news-73-1123-1.html)



执行某个操作，无论执行多少次，结果都是一致的，就说具有幂等性

**世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！——沈询**

>   确保幂等性可以在消息队列中避免消息重复消费



## 唯一ID + 指纹码

消息的唯一ID+指纹码双重保障消息是未消费的

>   指纹码: 可能是业务规则, 也可能是由硬件生成, 反正就是唯一

将唯一ID+指纹码 设置为数据库主键

`select count(1) from T_ORDER where id = <唯一ID+指纹码>`

如果上面的sql返回1 则说明消息已经消费

>   最好是查一些流水表, 因为流水表一般都用作查询和对账

*   优点： 实现简单
*   缺点：高并发下有数据库写入的性能瓶颈（解决方案：通过ID进行分库分表进行算法路由）



>   在一些要求比较高场景下推荐使用, 比如支付, 订单之类的
>
>   这个比redis 好的地方是持久化. 没有数据过期这个说法(redis 也可以做到, 不过总感觉没sql靠谱)



## Redis

利用redis的特性

`SET 1893505609317740 1466849127 EX 300 NX`

利用redis的问题是

-   如果要进行数据落库，关键解决的问题是数据库和缓存如何做到数据一致性。
-   如果不落库，那么都存在缓存中，如何设置定时同步的策略(同步是指将数据存储到数据库中，不落库指的是暂时不落库，不可能永远不落库)

